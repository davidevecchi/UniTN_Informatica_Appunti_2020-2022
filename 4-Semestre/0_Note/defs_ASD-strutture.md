# ASD – Strutture di dati

|      |                   |                                                              |
| ---- | :---------------: | -----------------------------------------------------------: |
| ASD  | Strutture di dati | [🗀][root]    [🗍](http://cricca.disi.unitn.it/montresor/teaching/asd/materiale/lucidi/)    [🖭](http://cricca.disi.unitn.it/montresor/teaching/asd/materiale/video/) |

[TOC]



# 1. Strutture di dati

## Strutture dati astratte

### Definizioni

#### Dati

> ­[^1] **Dato**
> ­[^2] **Tipo di dato primitivo**
> ­[^3] **Tipo di dato astratto**
> ­[^4] **Specifica di un TDA**
> ­[^5] **Implementazione di un TDA**
#### Strutture

> ­[^6] **Struttura di dati**
### Sequenze

> ­[^7] **Sequenza**
### Insiemi

> ­[^8] **Insieme**
### Dizionari

> ­[^9] **Dizionario**
### Alberi e grafi

> ­[^10] **Albero ordinato**
> ­[^11] **Grafo**
## Strutture dati elementari

### Liste

> ­[^12] **Lista concatenata**
> ­[^13] **Sequenza di nodi**
### Pile

> ­[^14] **Pila**
### Code

> ­[^15] **Coda**



# 2. Alberi

## Introduzione

### Definizioni

> ­[^16] **Albero radicato**
#### Terminologia

> ­[^17] **Profondità**
> ­[^18] **Livello**
> ­[^19] **Altezza**
## Alberi binari

### Introduzione

> ­[^20] **Albero binario**
> ­[^21] **Albero radicato**
### Alberi strutturalmente diversi

> ­[^22] **Alberi binari strutturalmente diversi**



# 3. Alberi binari di ricerca

## ABR bilanciati (RB)

### Definizioni

> ­[^23] **Fattore di bilanciamento**
### Alberi Red-Black

> ­[^24] **Albero Red-Black**
> ­[^25] **Altezza nera di un nodo $v$**
> ­[^26] **Altezza nera di un albero RB**



# 4. Grafi

## Introduzione

### Definizioni

> ­[^27] **Grafo (non) orientato**
> ­[^28] **Grafo pesato**
> ­[^29] **Grado di un nodo**
> ­[^30] **Cammino**
> ­[^31] **Cammino semplice**
> ­[^32] **Ciclo**
> ­[^33] **Ciclo semplice**
#### Casi speciali

> ­[^34] **Grafo completo**
> ­[^35] **Grafo sparso**
> ­[^36] **Grafo denso**
> ­[^37] **Grafo ciclico**
> ­[^38] **Grafo aciclico**
> ­[^39] **Grafo orientato aciclico / DAG**
> ­[^40] **Albero libero**
> ­[^41] **Albero radicato**
> ­[^42] **Foresta**
> ­[^43] **Grafo trasposto**
#### Componenti connesse

> ­[^44] **Sottografo**
> ­[^45] **Sottografo massimale**
> ­[^46] **Raggiungibilità**
> ­[^47] **Grafo connesso**
> ­[^48] **Grafo fortemente connesso**
> ­[^49] **Componente connessa**
> ­[^50] **Componente fortemente connessa**
#### Alberi di copertura

> ­[^51] **Albero di copertura**
> ­[^52] **Albero dei cammini minimi**
## Visite dei grafi

> ­[^53] **Visita per livelli**
> ­[^54] **Visita ricorsiva**
## DFS - DAG

### Classificazione degli archi

> ­[^55] **Arco dell'albero di copertura DFS**
### Ordinamento topologico

> ­[^56] **Ordinamento topologico**
### Componenti fortemente connesse

#### Grafo delle componenti

> ­[^57] **Grafo delle componenti**



# 5. Hashing

## Introduzione

### Definizioni

> ­[^58] **Insieme universo $\cal U$**
> ­[^59] **Funzione hash**
> ­[^60] **Tabella hash**
> ­[^61] **Collisione**
### Tabelle ad accesso diretto

> ­[^62] **Tabelle ad accesso diretto**
## Funzioni hash

### Funzioni hash perfette

> ­[^63] **Funzione hash perfetta**
### Uniformità semplice

> ­[^64] **Uniformità semplice**
## Gestione delle collisioni

### Indirizzamento aperto

#### Definizioni

> ­[^65] **Ispezione**
> ­[^66] **Estensione della funzione hash**
> ­[^67] **Sequenza di ispezione**
#### Tecniche di ispezione

> ­[^68] **Hashing uniforme**



# 7. Code con priorità

## Definizione

> ­[^69] **Priority queue**
## Vettore heap

### Heap

> ­[^70] **Heap**
### Alberi binari

> ­[^71] **Albero binario perfetto**
> ­[^72] **Albero binario completo**
### Alberi binari heap

> ­[^73] **Albero binario max-heap (min-heap)**



# 8. Insiemi disgiunti

## Introduzione

### Definizione

> ­[^74] **Collezione di insiemi dinamici disgiunti**
### Rappresentante

> ­[^75] **Rappresentante**
## Euristiche

### Alberi: euristica sul rango

> ­[^76] **Rango**







---




# Termini
- Dato[^1]
- Tipo di dato primitivo[^2]
- Tipo di dato astratto[^3]
- Specifica di un TDA[^4]
- Implementazione di un TDA[^5]
- Struttura di dati[^6]
- Sequenza[^7]
- Insieme[^8]
- Dizionario[^9]
- Albero ordinato[^10]
- Grafo[^11]
- Lista concatenata[^12]
- Sequenza di nodi[^13]
- Pila[^14]
- Coda[^15]
- Albero radicato[^16]
- Profondità[^17]
- Livello[^18]
- Altezza[^19]
- Albero binario[^20]
- Albero radicato[^21]
- Alberi binari strutturalmente diversi[^22]
- Fattore di bilanciamento[^23]
- Albero Red-Black[^24]
- Altezza nera di un nodo $v$[^25]
- Altezza nera di un albero RB[^26]
- Grafo (non) orientato[^27]
- Grafo pesato[^28]
- Grado di un nodo[^29]
- Cammino[^30]
- Cammino semplice[^31]
- Ciclo[^32]
- Ciclo semplice[^33]
- Grafo completo[^34]
- Grafo sparso[^35]
- Grafo denso[^36]
- Grafo ciclico[^37]
- Grafo aciclico[^38]
- Grafo orientato aciclico / DAG[^39]
- Albero libero[^40]
- Albero radicato[^41]
- Foresta[^42]
- Grafo trasposto[^43]
- Sottografo[^44]
- Sottografo massimale[^45]
- Raggiungibilità[^46]
- Grafo connesso[^47]
- Grafo fortemente connesso[^48]
- Componente connessa[^49]
- Componente fortemente connessa[^50]
- Albero di copertura[^51]
- Albero dei cammini minimi[^52]
- Visita per livelli[^53]
- Visita ricorsiva[^54]
- Arco dell'albero di copertura DFS[^55]
- Ordinamento topologico[^56]
- Grafo delle componenti[^57]
- Insieme universo $\cal U$[^58]
- Funzione hash[^59]
- Tabella hash[^60]
- Collisione[^61]
- Tabelle ad accesso diretto[^62]
- Funzione hash perfetta[^63]
- Uniformità semplice[^64]
- Ispezione[^65]
- Estensione della funzione hash[^66]
- Sequenza di ispezione[^67]
- Hashing uniforme[^68]
- Priority queue[^69]
- Heap[^70]
- Albero binario perfetto[^71]
- Albero binario completo[^72]
- Albero binario max-heap (min-heap)[^73]
- Collezione di insiemi dinamici disgiunti[^74]
- Rappresentante[^75]
- Rango[^76]







---
[^1]: **Dato**: *valore che una variabile può assumere*
---
[^2]: **Tipo di dato primitivo**: *fornito direttamente dal linguaggio*
---
[^3]: **Tipo di dato astratto**: *modello matematico, definito da una collezione di valori e un insieme di operazioni ammesse su questi valori*
---
[^4]: **Specifica di un TDA**: *interfaccia che nasconde i dettagli implementativi*
---
[^5]: **Implementazione di un TDA**: *realizzazione vera e propria*
---
[^6]: **Struttura di dati**: *collezione di dati, caratterizzata dall’organizzazione della stessa (piuttosto che dal tipo dei dati contenuti)*
---
[^7]: <u>Definizione</u>  (**Sequenza**)<br>Struttura dati **dinamica**, **lineare** che rappresenta una sequenza **ordinata** di valori che possono essere **ripetuti**<br><u>Operazioni</u><br>- Aggiungere/Togliere elementi (data la posizione)<br>- Accedere direttamente alla testa/coda<br>- Accedere sequenzialmente a tutti gli altri elementi
---
[^8]: <u>Definizione</u>  (**Insieme**)<br>Struttura dati **dinamica**, **non lineare** che memorizza una collezione **non ordinata** di elementi **senza valori ripetuti**<br><u>Operazioni</u><br>- Operazioni base<br>  - Inserimento<br>  - Cancellazione<br>  - Verifica contenimento<br>- Operazioni insiemistiche<br>  - Unione<br>  - Interesezione<br>  - Differenza<br>- Operazioni di ordinamento<br>  - Massimo<br>  - Minimo<br>- Iteratori<br>  - ${\tt foreach}\ x ∈ S\ {\tt do}$
---
[^9]: <u>Definizione</u>  (**Dizionario**)<br>Struttura dati che rappresenta il concetto matematico di **relazione univoca** o **associazione chiave-valore**<br>$$R\ :\ D → C$$<br>- $D\,$: **chiavi**<br>- $C\,$: **valori**<br><u>Operazioni</u><br>- Ottenere il valore associato ad una particolare chiave o $\tt nil$ se assente<br>- Inserire una nuova associazione chiave-valore, cancellando eventuali associazioni precedenti per la stessa chiave<br>- Rimuovere un’associazione chiave-valore esistente
---
[^10]: <u>Definizione</u>  (**Albero ordinato**)<br>Insieme finito di elementi detti **nodi**<br>- Uno di essi è designato come **radice**<br>- I nodi rimanenti sono partizionati in insiemi **ordinati** e **disgiunti**, anch’essi alberi ordinati
---
[^11]: <u>Definizione</u>  (**Grafo**)<br>Struttura dati composta da<br>- insieme di elementi detti **nodi** o **vertici**<br>- insieme di coppie (ordinate o no) di nodi detti **archi**
---
[^12]: <u>Definizione</u>  (**Lista concatenata**)<br>
---
[^13]: **Sequenza di nodi**, contenenti dati arbitrari e 1 o 2 **puntatori** all’elemento successivo e/o precedente
---
[^14]: <u>Definizione</u>  (**Pila**)<br>Struttura dati **dinamica**, **lineare** in cui l’elemento rimosso dall’operazione di cancellazione è predeterminato secondo il sistema **LIFO** (last-in first-out)
---
[^15]: <u>Definizione</u>  (**Coda**)<br>Struttura dati **dinamica**, **lineare** in cui l’elemento rimosso dall’operazione di cancellazione è predeterminato secondo il sistema **FIFO** (first-in first-out)
---
[^16]: <u>Definizione</u>  (**Albero radicato**)<br>Insieme di **nodi** e insieme di **archi orientati** che connettono coppie di nodi, con le seguenti proprietà<br>- Un nodo dell’albero è designato come **nodo radice**<br>- Ogni nodo, radice esclusa, ha esattamente **un arco entrante**<br>- Esiste un **cammino unico** dalla radice ad ogni nodo<br>- L’albero è **connesso**<br><u>Definizione ricorsiva</u><br>Un albero è dato da (xor)<br>- Un **insieme vuoto**<br>- Un **nodo radice** e zero o più **sottoalberi**, ognuno dei quali è un albero<br>  - La radice è connessa a radici di ogni sottoalbero con **archi orientati**
---
[^17]: **Profondità**: *lunghezza del cammino semplice dalla radice a un nodo*
---
[^18]: **Livello**: *insieme di nodi alla stessa profondità*
---
[^19]: **Altezza**: *profondità massima della sue foglie*
---
[^20]: <u>Definizione</u>  (**Albero binario**)<br>
---
[^21]: **Albero radicato** in cui ogni nodo ha **al massimo due figli**, identificati come figlio sinistro e figlio destro
---
[^22]: <u>Definizione</u>  (**Alberi binari strutturalmente diversi**)<br>Due alberi binari si dicono strutturalmente diversi se disegnando i figli destri e sinistri si ottengono figure diverse
---
[^23]: <u>Definizione</u>  (**Fattore di bilanciamento**)<br>Il fattore di bilanciamento $β(v)$ di un nodo $v$ è la **massima differenza** di altezza fra i sottoalberi di $v$
---
[^24]: <u>Definizione</u>  (**Albero Red-Black**)<br>ABR in cui<br>- Ogni nodo è colorato di **rosso** o di **nero**<br>- Le **chiavi** vengono mantenute solo nei **nodi interni** dell’albero<br>- Le **foglie** sono costituite da nodi speciali $\tt Nil$<br>- Vengono rispettati i seguenti **vincoli**<br>  1. La **radice** è nera<br>  2. Tutte le **foglie** sono nere<br>  3. Entrambi i **figli** di un nodo rosso sono neri<br>  4. Ogni **cammino** semplice da un nodo $u$ ad una delle foglie contenute nel suo sottoalbero ha lo stesso numero di nodi neri
---
[^25]: <u>Definizione</u>  (**Altezza nera di un nodo $v$**)<br>L’altezza nera ${\rm bh}(v)$ di un nodo $v$ è il numero di nodi neri lungo ogni cammino da $v$ (escluso) ad ogni foglia (inclusa) del suo sottoalbero
---
[^26]: <u>Definizione</u>  (**Altezza nera di un albero RB**)<br>Altezza nera della sua radice
---
[^27]: <u>Definizione</u>  (**Grafo (non) orientato**)<br>Coppia $G = (V, E)$ dove<br>- $V$ è un insieme di **nodi** / **vertici**<br>- $E$ è un insieme di **coppie (non) ordinate** $(u, v)$ di nodi dette **archi**<br>
---
[^28]: <u>Definizione</u>  (**Grafo pesato**)<br>- Grafo i cui archi hanno un **peso**<br>- Il peso $w(u,v)$ di un arco è dato da una **funzione di peso**<br>  $$  w\ :\ V × V → \R  $$<br>- Se non esiste l'arco, il peso ha un valore $ω$ arbitrario<br>  - Dipende dal problema
---
[^29]: <u>Definizione</u>  (**Grado di un nodo**)<br>- **Grafi non orientati**<br>  - Numero di archi incidenti su di esso<br>- **Grafi orientati**<br>  - **Entrante**: numero di archi incidenti su di esso<br>  - **Uscente**: numero di archi incidenti da esso
---
[^30]: <u>Definizione</u>  (**Cammino**)<br>Un cammino $C$ di lunghezza $k$ è una **sequenza di nodi**<br>$$u_0 , u_1 , . . . , u_k\in V\ :\ (u_i , u_{i+1}) ∈ E,\ \ \forall\, i\in[0,k)$$<br>
---
[^31]: <u>Definizione</u>  (**Cammino semplice**)<br>Cammino in cui tutti i suoi nodi sono distinti
---
[^32]: <u>Definizione</u>  (**Ciclo**)<br>Un ciclo $C$ di lunghezza $k > 2$ è una **sequenza di nodi**<br>$$u_0 , u_1 , . . . , u_k\in V\ :\ (u_i , u_{i+1}) ∈ E\ \and\ u_0=u_k,\ \ \forall\, i\in[0,k)$$<br>
---
[^33]: <u>Definizione</u>  (**Ciclo semplice**)<br>Ciclo in cui tutti i suoi nodi sono distinti, ad eccezione di primo e ultimo
---
[^34]: <u>Definizione</u>  (**Grafo completo**)<br>Grafo con un arco fra tutte le coppie di nodi
---
[^35]: <u>Definizione informale</u>  (**Grafo sparso**)<br>Grafo con pochi archi (e.g. $m = O(n)$, $m = O(n \log n)$)<br>
---
[^36]: <u>Definizione informale</u>  (**Grafo denso**)<br>Grafo con tanti archi (e.g. $m = Ω(n^2)$)
---
[^37]: <u>Definizione</u>  (**Grafo ciclico**)<br>Grafo che contiene almeno un ciclo<br>
---
[^38]: <u>Definizione</u>  (**Grafo aciclico**)<br>Grafo non orientato che non contiene cicli<br>
---
[^39]: <u>Definizione</u>  (**Grafo orientato aciclico / DAG**)<br>Grafo orientato che non contiene cicli
---
[^40]: <u>Definizione</u>  (**Albero libero**)<br>Grafo connesso con $m = n − 1$<br>
---
[^41]: <u>Definizione</u>  (**Albero radicato**)<br>Albero libero nel quale uno dei nodi è designato come **radice/sorgente**
---
[^42]: <u>Definizione</u>  (**Foresta**)<br>Grafo formato da un insieme di alberi
---
[^43]: <u>Definizione</u>  (**Grafo trasposto**)<br>Dato un grafo orientato $G = (V, E)$, il grafo trasposto $G^T=(V,E_T)$ ha gli stessi nodi e gli archi orientati in **senso opposto**<br>$$E_T = \{(u, v)\ |\ (v, u) ∈ E\}$$
---
[^44]: <u>Definizione</u>  (**Sottografo**)<br>$G'$ è un sottografo di $G$ se e solo se<br>$$G' ⊆ G\ \iff\ V'⊆V\ \and\ E'⊆E$$<br>
---
[^45]: <u>Definizione</u>  (**Sottografo massimale**)<br>$G'$ è un sottografo massimale di $G$ se e solo se<br>$$G'_{\max}\sube G \ \iff\ \nexists\,G''⊆G\ :\ G''_{\sf connesso}\ \and\ G' \sub G''$$
---
[^46]: <u>Definizione</u>  (**Raggiungibilità**)<br>Un nodo $v$ è raggiungibile da $u$ se esiste almeno un **cammino** da $u$ a $v$
---
[^47]: <u>Definizione</u>  (**Grafo connesso**)<br>Un grafo non orientato $G = (V, E)$ è connesso se e solo se ogni suo nodo è **raggiungibile** da ogni altro suo nodo<br>
---
[^48]: <u>Definizione</u>  (**Grafo fortemente connesso**)<br>Come sopra, con un grafo orientato
---
[^49]: <u>Definizione</u>  (**Componente connessa**)<br>Un grafo non orientato $G' = (V' , E' )$ è una componente connessa di $G$ se e solo se $G'$ è un sottografo connesso e massimale di $G$<br>
---
[^50]: <u>Definizione</u>  (**Componente fortemente connessa**)<br>Come sopra, con un grafo orientato
---
[^51]: <u>Definizione</u>  (**Albero di copertura**)<br>Dato un grafo $G = (V, E)$ non orientato e connesso, un albero di copertura di $G$ è un sottografo $T = (V, E_T)$ tale che<br>- $T$ è un albero<br>- $E_T ⊆ E$<br>- $T$ contiene tutti i vertici di $G$
---
[^52]: <u>Definizione</u>  (**Albero dei cammini minimi**)<br>Albero di copertura radicato in $s$ avente un cammino da $s$ a tutti i nodi raggiungibili da $s$
---
[^53]: **Visita per livelli**: prima la radice, poi i nodi a distanza $i$ da essa<br>
---
[^54]: **Visita ricorsiva**: per ogni nodo si visitano tale nodo e i suoi nodi adiacenti
---
[^55]: **Arco dell'albero di copertura DFS**: *arco esaminato da un nodo marcato ad un nodo non marcato*
---
[^56]: <u>Definizione</u>  (**Ordinamento topologico**)<br>Ordinamento lineare dei nodi di un DAG $G$, tale per cui<br>$$(u,v)\in E\ \Rarr\ u<v$$
---
[^57]: <u>Definizione</u>  (**Grafo delle componenti**)<br>$$C(G) = (V_c , E_c )$$<br>- $V_c = \{C_1 , C_2 , . . . , C_k \}$<br>  - $C_i$ è la $i$-esima SCC di $G$<br>- $E_c = \{(C_i , C_j )\ |\ ∃\,(u_i , u_j ) ∈ E\ :\ u_i ∈ C_i\ ∧\ u_j ∈ C_j \}$<br><u>Proprietà</u><br>- $C$ è aciclico<br>- $C(G^T) = [C(G)]^T$<br>- $\rm dt$ e $\rm ft$ di $C$ corrispondono a quelli del primo nodo visitato in $C$<br>  - ${\rm dt}(C) = \min\,\{{\rm dt}(u)\ |\ u ∈ C\}$<br>  - ${\rm ft}\,(C) = \max\{{\rm ft}(u)\,\ |\ u ∈ C\}$
---
[^58]: **Insieme universo $\cal U$**: *insieme delle possibili chiavi, di dimensione $\,\#\cal U=u$*
---
[^59]: **Funzione hash**: *funzione $H$ che mappa chiavi $k ∈ \cal U$ in interi $H(k)$*
---
[^60]: <u>Definizione</u>  (**Tabella hash**)<br>Vettore $T\,[0, . . ., m − 1]$ di dimensione $m$, in cui<br>-  Gli elementi di $T$ appartengono all'insieme $\,\cal U$<br>- La posizione degli elementi è determinata da una funzione hash<br>  $$  H\ :\ {\cal U} → \{0, 1, . . . , m − 1\}  $$
---
[^61]: **Collisione**: *due o più chiavi nel dizionario mappate nello stesso valore hash*
---
[^62]: <u>Definizione</u>  (**Tabelle ad accesso diretto**)<br>Caso particolare in cui $\,\cal U$ è un **sottoinsieme** (piccolo) di $\Z^+$<br>- Si utilizza la funzione hash identità $H(k) = k$<br>- Si sceglie un valore $m = u$
---
[^63]: <u>Definizione</u>  (**Funzione hash perfetta**)<br>Funzione hash **iniettiva**<br>$$∀\,k_1,k_2 ∈ {\cal U}\ :\ k_1 \neq k_2\ \Rarr\ H(k_1) \neq H(k_2)$$
---
[^64]: <u>Definizione</u>  (**Uniformità semplice**)<br>- Sia $P (k)$ la probabilità che una chiave $k$ *possa apparire* nella tabella<br>  <br>- Sia $Q(i)$ la probabilità che una chiave finisca nella cella $i$<br>  $$   Q(i)=\sum_{k\in{\cal U}\, :\, H(k)=i} P(k)  $$<br>Una funzione hash $H$ gode di uniformità semplice se<br>$$\,i ∈ \{0, . . . , m − 1\}\,,\ \ Q(i) = \frac1 m$$
---
[^65]: **Ispezione**: *esame di uno slot durante la ricerca*
---
[^66]: <u>Definizione</u>  (**Estensione della funzione hash**)<br>$$H\ :\ {\cal U} × \underbrace{[0,...,m-1]}_\text{Numero ispezione}\ →\ \underbrace{[0,...,m-1]}_\text{Indice vettore}$$
---
[^67]: <u>Definizione</u>  (**Sequenza di ispezione**)<br>Una sequenza di ispezione<br>$$[H(k, 0), H(k, 1), . . . , H(k, m − 1)]$$<br>è una **permutazione degli indici** $[0, . . . , m − 1]$ corrispondente all’ordine in cui vengono esaminati gli slot
---
[^68]: <u>Definizione</u>  (**Hashing uniforme**)<br>Situazione ideale in cui ogni chiave ha la stessa probabilità di avere come sequenza di ispezione una qualsiasi delle $m!$ permutazioni di $[0, . . . , m − 1]$
---
[^69]: <u>Definizione</u>  (**Priority queue**)<br>Struttura dati astratta, simile ad una coda, in cui ogni elemento inserito possiede una sua priorità<br>- **Min-priority queue**: estrazione per valori crescenti di priorità<br>- **Max-priority queue**: estrazione per valori decrescenti di priorità<br><u>Operazioni</u><br>- Inserimento in coda<br>- Estrazione dell’elemento con priorità di valore min/max<br>- Modifica priorità (decremento/incremento) di un elemento inserito
---
[^70]: <u>Definizione</u>  (**Heap**)<br>Struttura dati speciale che associa i **vantaggi** di<br>- **Alberi**: esecuzione in tempo $O(\log n)$<br>- **Vettori**: memorizzazione efficiente
---
[^71]: <u>Definizione</u>  (**Albero binario perfetto**)<br>- Tutte le foglie hanno la stessa profondità $h$<br>- Tutti i nodi interni hanno tutti grado $2$<br>- Dato il numero di nodi $n$, ha altezza $h = \lfloor \log n \rfloor$<br>- Data l’altezza $h$, possiede $n = 2^{h+1} − 1$ nodi
---
[^72]: <u>Definizione</u>  (**Albero binario completo**)<br>- Tutte le foglie hanno la stessa profondità $h$ o $h-1$<br>- Tutti i nodi a livello $h$ sono 'accatastati' a sinistra<br>- Tutti i nodi interni hanno grado $2$, eccetto al più uno<br>- Dato il numero di nodi $n$, ha altezza $h = \lfloor \log n \rfloor$
---
[^73]: <u>Definizione</u>  (**Albero binario max-heap (min-heap)**)<br>Albero binario completo tale che il valore memorizzato in ogni nodo è maggiore (minore) dei valori memorizzati nei suoi figli<br><u>Proprietà</u><br>- Non impone una relazione di ordinamento totale fra i figli di un nodo<br>- È un **ordinamento parziale**<br>  - Riflessivo:  $n\ge n$<br>  - Antisimmetrico:  $n ≥ m\ \and\ m ≥ n\ \Rarr\ n = m$<br>  - Transitivo:  $n ≥ m \ \and\ m ≥ r \ \Rarr\ n ≥ r$
---
[^74]: <u>Definizione</u>  (**Collezione di insiemi dinamici disgiunti**)<br>Collezione $S = \{S_1 , S_2 , . . . , S_k \}$ tale per cui<br>- $∀i, j : i \ne j\ ⇒\ S_i ∩ S_j = Ø$<br>- $\bigcup^k_{i=1} S_i = S,\ \ {\rm dove}\; k = |S|$
---
[^75]: <u>Definizione</u>  (**Rappresentante**)<br>Il rappresentante dell’insieme $S_i$ è un suo qualunque membro che lo identifica univocamente
---
[^76]: <u>Definizione</u>  (**Rango**)<br>Il rango ${\rm rank}[x]$ di un nodo $x$ è il numero di archi del cammino più lungo fra $x$ e una foglia sua discendente<br>- Rango $≡$ altezza del sottoalbero associato al nodo
---
